---
title: Capítulo 13 — Entrada y salida de datos (I/O)
description: Explicación completa del manejo de archivos de texto, binarios y de propiedades en Java, incluyendo el uso de try-with-resources.
---

# Capítulo 13 — Entrada y salida de datos (I/O)

La **entrada/salida (I/O)** en Java se gestiona a través de flujos (*streams*) que permiten leer y escribir datos desde distintas fuentes: teclado, archivos, red o memoria.

---

## 13.1. Tipos de flujos

| Tipo | Descripción | Ejemplo de clases |
|------|--------------|------------------|
| **Flujos de bytes** | Trabajan con datos binarios (imágenes, archivos `.dat`, etc.) | `InputStream`, `OutputStream`, `FileInputStream`, `FileOutputStream` |
| **Flujos de caracteres** | Trabajan con texto (archivos `.txt`, `.csv`, etc.) | `Reader`, `Writer`, `FileReader`, `FileWriter`, `BufferedReader`, `BufferedWriter` |

---

## 13.2. Lectura y escritura de archivos de texto

### Escritura básica

```java
import java.io.FileWriter;
import java.io.IOException;

public class EscribirTexto {
    public static void main(String[] args) {
        try (FileWriter fw = new FileWriter("salida.txt")) {
            fw.write("Primera línea\n");
            fw.write("Segunda línea\n");
        } catch (IOException e) {
            System.err.println("Error al escribir el archivo: " + e.getMessage());
        }
    }
}
```

### Lectura con `BufferedReader`

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class LeerTexto {
    public static void main(String[] args) {
        try (BufferedReader br = new BufferedReader(new FileReader("salida.txt"))) {
            String linea;
            while ((linea = br.readLine()) != null) {
                System.out.println(linea);
            }
        } catch (IOException e) {
            System.err.println("Error al leer el archivo: " + e.getMessage());
        }
    }
}
```

> `try-with-resources` garantiza el cierre automático del archivo incluso si ocurre una excepción.

---

## 13.3. Escritura y lectura de archivos binarios

### Escritura

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class EscribirBinario {
    public static void main(String[] args) {
        byte[] datos = {65, 66, 67, 68}; // A, B, C, D
        try (FileOutputStream fos = new FileOutputStream("datos.bin")) {
            fos.write(datos);
        } catch (IOException e) {
            System.err.println("Error al escribir archivo binario: " + e.getMessage());
        }
    }
}
```

### Lectura

```java
import java.io.FileInputStream;
import java.io.IOException;

public class LeerBinario {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("datos.bin")) {
            int b;
            while ((b = fis.read()) != -1) {
                System.out.print((char) b + " ");
            }
        } catch (IOException e) {
            System.err.println("Error al leer archivo binario: " + e.getMessage());
        }
    }
}
```

---

## 13.4. Acceso a archivos con `java.nio.file`

El paquete `java.nio.file` (Java 7+) simplifica muchas operaciones de archivo mediante las clases `Path` y `Files`.

```java
import java.nio.file.*;

public class EjemploNIO {
    public static void main(String[] args) {
        Path ruta = Path.of("salida.txt");

        try {
            String contenido = Files.readString(ruta);
            System.out.println("Contenido del archivo:\n" + contenido);

            Files.writeString(Path.of("nuevo.txt"), "Archivo generado con NIO");
        } catch (IOException e) {
            System.err.println("Error de E/S: " + e.getMessage());
        }
    }
}
```

---

## 13.5. Ficheros de propiedades (`.properties`)

Los ficheros `.properties` se usan para almacenar configuraciones en formato clave=valor.  
Por ejemplo:

```
usuario=admin
password=1234
servidor=localhost
puerto=5432
```

### Carga y lectura

```java
import java.io.FileReader;
import java.io.IOException;
import java.util.Properties;

public class LeerProperties {
    public static void main(String[] args) {
        Properties config = new Properties();
        try (FileReader fr = new FileReader("config.properties")) {
            config.load(fr);

            String usuario = config.getProperty("usuario");
            String servidor = config.getProperty("servidor");
            System.out.println("Usuario: " + usuario);
            System.out.println("Servidor: " + servidor);
        } catch (IOException e) {
            System.err.println("Error al leer properties: " + e.getMessage());
        }
    }
}
```

---

### Obtener valores con valor por defecto

El método `getProperty(String clave, String valorPorDefecto)` devuelve un valor por defecto si la clave no existe.

```java
String puerto = config.getProperty("puerto", "3306");
System.out.println("Puerto: " + puerto);
```

#### Casos de uso:
- Proporcionar valores iniciales sin necesidad de editar el archivo.  
- Permitir ejecutar el programa aunque falte una configuración.  
- Implementar configuraciones por entorno (producción, desarrollo, etc.).

---

### Guardar propiedades en un archivo

```java
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

public class GuardarProperties {
    public static void main(String[] args) {
        Properties config = new Properties();
        config.setProperty("usuario", "admin");
        config.setProperty("servidor", "localhost");

        try (FileWriter fw = new FileWriter("config.properties")) {
            config.store(fw, "Archivo de configuración");
        } catch (IOException e) {
            System.err.println("Error al guardar properties: " + e.getMessage());
        }
    }
}
```

> Los ficheros `.properties` se empaquetan normalmente dentro del recurso del proyecto (`src/main/resources`), de forma que se incluyan en el `.jar` final.

---

## 13.6. Localización de archivos dentro del JAR

Cuando el archivo `.properties` está dentro del proyecto, se puede cargar con un **ClassLoader**, sin indicar ruta absoluta:

```java
try (InputStream entrada = MiClase.class.getResourceAsStream("/config.properties")) {
    Properties config = new Properties();
    config.load(entrada);
}
```

> Esto permite acceder a configuraciones incluidas dentro del JAR en tiempo de ejecución.

---

## 13.7. Try con recursos (`try-with-resources`)

Esta estructura garantiza que todos los recursos que implementan la interfaz `AutoCloseable` se cierren automáticamente.

```java
try (BufferedReader br = new BufferedReader(new FileReader("archivo.txt"))) {
    br.lines().forEach(System.out::println);
} catch (IOException e) {
    System.err.println("Error: " + e.getMessage());
}
```

### Reglas
- Los recursos deben declararse dentro del paréntesis del `try`.  
- No es necesario `finally` para cerrarlos manualmente.  
- Puede declararse más de un recurso:

```java
try (FileReader fr = new FileReader("a.txt");
     FileWriter fw = new FileWriter("b.txt")) {
    fw.write(fr.read());
}
```

---

## 13.8. Tabla resumen de clases principales

| Clase | Paquete | Función principal |
|--------|----------|------------------|
| `File` | `java.io` | Representa rutas de archivos o directorios |
| `FileReader` / `FileWriter` | `java.io` | Lectura/escritura de texto carácter a carácter |
| `BufferedReader` / `BufferedWriter` | `java.io` | Lectura/escritura eficiente por líneas |
| `InputStream` / `OutputStream` | `java.io` | Flujos base para datos binarios |
| `FileInputStream` / `FileOutputStream` | `java.io` | Lectura/escritura binaria directa |
| `DataInputStream` / `DataOutputStream` | `java.io` | Lectura/escritura de tipos primitivos |
| `ObjectInputStream` / `ObjectOutputStream` | `java.io` | Serialización de objetos |
| `Path` | `java.nio.file` | Representa rutas de archivos modernas |
| `Files` | `java.nio.file` | Métodos estáticos para trabajar con archivos |
| `Properties` | `java.util` | Almacenamiento de configuraciones clave=valor |

---

## 13.9. Resumen

- Los flujos (`streams`) permiten leer y escribir datos secuenciales.  
- Los archivos de texto usan `Reader`/`Writer`; los binarios, `InputStream`/`OutputStream`.  
- `try-with-resources` garantiza el cierre automático de recursos.  
- Los archivos `.properties` son útiles para configuraciones y admiten valores por defecto.  
- El paquete `java.nio.file` ofrece una API moderna, segura y eficiente para operaciones con archivos.
